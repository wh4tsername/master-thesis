\subsection{Эвристики для ускорения перебора}

Выше была описана наивная реализация model checker-а. На тривиальных примерах была возможность проверить работоспособность инструмента. Но если реализовать какой-либо распределенный алгоритм с использованием RPC сервисов и декомпозицией их на несколько частей, то перебор состояний не завершается за несколько часов. Более того, даже на поиск бага в очевидно неправильном коде затрачивается масса времени.

Далее мы рассмотрим эвристики. Они должны, с одной стороны, не позволять нам упускать содержательные состояния кода. С другой, ускорять перебор и не требовать огромных ресурсов.

\subsubsection{Хэширование состояний}

Напомним, что мы не храним явно состояния системы для перебора. Такая техника подходит под наши ограничения по ресурсам, и она позволяет тратить намного меньше памяти, однако минусом является сложность в поддержании посещенных вершин графа конфигураций. Без этого checker может перебирать экспоненциальное число исполнений, которые имеют совпадающий суффикс, но разный префикс.

В данном случае на помощь приходит хэширование состояний \cite{hash}. Используя стойкую к коллизиям 64-битную хэш-функцию и алгоритм комбинирования хэшей, мы можем быть уверены в небольшом количестве коллизий. Поддержание множества посещенных хэшей дает заметное ускорение.

Для избежания коллизий хэш системы будет являться комбинацией хэшей каждого из узлов и хэша сети. Для комбинации хэшей используется алгоритм hash\_combine из библиотеки boost \cite{boost}. Такой способ составления хэша является некоммутативным и стойким к коллизиям.

Хэш сети – это комбинация хэшей сообщений. Здесь стоит остановится на том, как именно комбинировать хэши сообщений. В исполнениях с разными префиксами, но одинаковыми суффиксами, в сети на момент начала совпадения будут лежать одинаковые сообщения. Однако порядок сообщений будет различным. Поэтому есть два варианта: коммутативный способ комбинирования хэшей сообщений и задание канонического порядка. Как правило, из-за коммутативных хэшей возникает множество коллизий, что критично в нашем случае. Поэтому зададим канонический порядок сортировкой сообщений в сети по хэшу. 

Сортировку производим по запросу хэша от сети. Важно, что сортировка будет проводиться на буфере небольшого объема, так как с ростом числа сообщений количество времени на перебор растет намного быстрее. Поэтому главный параметр выбора алгоритма сортировки – эффективность для маленьких входных данных. Хорошо подходит алгоритм сортировки вставками. Хотя он проигрывает асимптотически другим алгоритмам, на практике на небольшом входе работает быстрее за счет маленькой константы.

Хэш сообщения – хэш полей структуры ActorMessage, которая представляет пакет на сетевом уровне. Хэш пакета вычисляется на стадии его создания, чтобы при запросе хэша сети время затрачивалось только на сортировку и комбинирование пакетов.

Для узла хэшом будет являться хэш памяти и хэш диска. Хэш памяти определяется как хэш аллокатора – комбинация размеров аллокаций для узла. Хэш диска – хэш упорядоченных по ключу пар (ключ, значение) в базе данных, который пересчитывается при каждом выполненном Put. 

\subsubsection{Моментальная доставка ответов}

Для этой эвристики воспользуемся знанием о том, какие сообщения проходят через сеть: запросы и ответы протокола RPC.

С ростом числа сообщений экспоненциально растет число исполнений, т.е. путей в графе конфигураций теста. Мы можем наполовину сократить количество сообщений, если будем доставлять ответы RPC моментально, что сокращает перебор.

\subsubsection{Хэширование памяти узла}

Состояние узла определяется состоянием его диска, его оперативной памяти и регистрами процессоров. Но если учесть, что вся concurrency, написанная в узле является реализацией автомата, а все рассматриваемые алгоритмы (ABD, Raft и т.п.) описываются в виде автоматов, то мы можем не учитывать в хэше точное и сложное состояние исполнения. Достаточно учитывать ключевые переменные, задействованные в алгоритме. А в силу устойчивости алгоритма к рестартам узлов эти переменные уже хранятся на диске узла, так что будем хэшировать только диск.

Например, для алгоритма Raft в спецификации на языке TLA+ можно явно задать то, какие переменные не изменяются при переходах между фазами алгоритма \cite{raft}.
