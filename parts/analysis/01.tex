\subsection{Model checking}

Другой подход к тестированию распределенных систем – model checking – состоит в переборе всех достижимых во время исполнения теста состояний системы или алгоритма. 

Все состояния, достижимые в конкретном тесте, можно представить  виде ориентированного графа: 
\begin{itemize}
    \item вершины – конфигурации – описывают мгновенное состояние всей системы, образованное состоянием каждого узла и состоянием сети
    \item дуги в этом графе означают доставку сообщения: при получении сообщения узел меняет свое состояние, возможно отправляя в сеть новые сообщения. 
\end{itemize}

Такой граф назовем графом конфигураций. Каждое конкретное исполнение (обслуживание запросов системой) представляется в графе в виде пути.

Свойства системы имеют разную локализацию в графе конфигураций. Safety свойства – не происходит ничего плохого (например, не нарушается линеаризуемость) – это утверждения про отдельные состояния в этом графе, liveness свойства – когда-нибудь произойдет что-то хорошее (например, при стремлении количества запросов клиентов к бесконечности, количество ответов тоже стремится к бесконечности) – это утверждения про пути в графе.

Задача model checking-а – для теста системы построить граф конфигураций и исследовать выполнение требуемых свойств во всех вершинах или на всех путях этого графа. Компонент, который выполняет такой перебор, назовем model checker.

Когда есть потребность в использовании данной техники, для интересующих критичных частей системы нужно сперва написать спецификацию на формальном языке, которая уже будет проверяться с помощью конкретного инструмента.

В индустрии стандартным инструментом для model checking является формальный язык для написания спецификаций алгоритмов – TLA+ и checker для него – TLC \cite{tla}.

В отличие от fault-injection, эта техника тестирования позволяет гарантированно находить ошибки в алгоритмах. Главный минус подхода – проверяется не реализация системы, а ее спецификация на формальном языке.
