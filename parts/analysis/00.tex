\subsection{Fault-injection}

Fault-injection – техника тестирования недетерминированных конкурентных программ (многопоточных и/или распределенных). Для программы пишется нагрузочный тест, который проверяет наблюдаемые свойства системы (например, модель согласованности), а затем в исполнение этого теста рандомизированно внедряются сбои.

В случае распределенной системы сбоями будут:
\begin{itemize}
    \item Задержка и переупорядочивание сообщений 
    \item Разбиение сети на несколько изолированных друг от друга сегментов, внутри которых сохраняется связность
    \item Отказ узла
    \item Перезагрузка узла, а следовательно, сброс содержимого оперативной памяти
    \item Сдвиг или дрейф локальных часов узла
\end{itemize}

Случайные сбои позволяют увеличить покрытие достижимых в исполнении состояний системы.

Внедрение сбоев может быть реализовано двумя способами: неинвазивный fault-injection и fault-injection в детерминированной симуляции.

Неинвазивность означает, что для тестирования не требуется вносить изменения в код тестируемой системы. Узлы системы запускаются в виртуальном окружении (в отдельных контейнерах), а поведение сети и часов на узлах (сеть и время – основные источники недетерминизма) управляется с помощью системных утилит Linux.

В индустрии стандартом де-факто для неинвазивного fault-injection тестирования распределенных систем является фреймворк Jepsen \cite{jepsen}.

Вариант с fault-injection в детерминированной симуляции состоит в подмене примитивов и абстракций, на которых строится система, для внедрения в них сбоев. У этого подхода есть своя цена – этот тип тестирования должен быть заложен непосредственно в дизайн системы. Примером промышленной системы, которая использует для тестирования fault-injection в симуляции, является база данных FoundationDB \cite{foundation_db}. Также детерминированная симуляция поддерживается в качестве одного из механизмов исполнения в фреймворке курса распределенных систем – whirl-matrix \cite{whirl}.

У техники fault-injection есть очевидное ограничение – рандомизированные сбои не гарантируют, что будут исследованы все возможные состояния, потенциально достижимые в тесте. 
