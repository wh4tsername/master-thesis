\subsection{Дополнения алгоритма}

\subsubsection{Сохранение сортированности}

Сохранение сортированности может быть легко встроено в текущий алгоритм. Правила, по которым будет происходить оптимизация помечены знаком "+" (рис.~\ref{fig:rule1})

\subsubsection{Когда не стоит оптимизировать}

В процессе преобразования данных размер данных, ассоциированный с каждым ключом, может значительно измениться. Если трансформация включает фильтрацию данных, то объем данных по ключу уменьшается. Напротив, если трансформация предполагает декомпозицию или увеличение детализации данных, объем увеличивается. Поэтому от того, в каком порядке и какие именно преобразования будут объединены может зависеть количество пропускаемых через систему промежуточных данных \cite{flume}.

Слияние независимых веток графа данных может быть эффективным решением для упрощения структуры, однако такой подход имеет свои ограничения. Важно учитывать, что при таком слиянии может пропасть параллельность исполнения операций, что может повлиять на общую производительность процессинга данных.

При проектировании операций в рамках системы возможно установление лимитов на использование ресурсов для каждой операции. Эти лимиты можно учитывать при слиянии операций, что поможет оптимизировать расход ресурсов и повысить эффективность выполнения задач.

Применение правил слияния с учетом сортированности данных может значительно повысить эффективность обработки. Однако, перед тем как использовать эти правила повсеместно, рекомендуется выполнить предварительный обход графа и определить, до какого уровня сортированность данных сохраняется на разных этапах обработки.

В случае, если в графе встречаются преобразования отличные от покрытых Wrapper-ами, их можно не оптимизировать в ходе обхода, сохраняя корректность.
